# üéâ Reimplementation of CloudFlare DDNS in Go

This is a reimplementation of https://github.com/timothymiller/cloudflare-ddns **with many significant improvements.**

## üöß Status of the Project

The code is working well for me, but the repository is still young. The interface is subject to changes.

## üëè Notable Improvements

1. **It will _not_ delete any A or AAAA records** that are not specified by you. The way the original program handles stale records has surprised many people; see [timothymiller/cloudflare-ddns#52](https://github.com/timothymiller/cloudflare-ddns/pull/52) and [#57](https://github.com/timothymiller/cloudflare-ddns/pull/57), for example. This will never happen in the new implementation.
2. It is mainly **configured via environment variables,** which means all the settings can go into `.env` when using `docker-compose`. This immediately solves [timothymiller/cloudflare-ddns#35](https://github.com/timothymiller/cloudflare-ddns/pull/35) and [#41](https://github.com/timothymiller/cloudflare-ddns/pull/41).
3. It can also be a **drop-in replacement** with `COMPATIBLE=true`. See below.
4. It _will_ respect `PGID` and `PUID` and **drop the root privilege immediately.**
5. It can take fully qualified domain names and **find the correct zones IDs for you.**
6. It can be configured to obtain IP addresses **using local network interfaces**, solving [#36](https://github.com/timothymiller/cloudflare-ddns/issues/36).
7. It comes with **many technical improvements under the hood,** such as handling of pagination in the CloudFlare API (thanks to the official Go binding [cloudflare/cloudflare-go](https://github.com/cloudflare/cloudflare-go)), careful parsing of the JSON files, (still incomplete) timeout mechanism, caching (thanks to [patrickmn/go-cache](https://github.com/patrickmn/go-cache)), etc.

As a bonus, the implementation has a tiny footprint and **its Docker images are only of size about 5 MBs.** (The Docker image of the original CloudFlare-DDNS is also small, but this one is even smaller.)

## üõ†Ô∏è Usage with Docker Compose

### ü§ù Compatible Mode

Use this option if you already have a working JSON configuration for CloudFlare-DDNS and do not want to update it.

#### üö£ Migration Steps

1. Change `timothyjmiller/cloudflare-ddns:latest` to **`ghcr.io/favonia/cloudflare-ddns-go:latest`** in your `docker-compose.yml` file (or other equivalent ones).
2. Under `environment`, **add `COMPATIBLE=true`** to enable the compatible mode.
3. If you have been specifying `container_name`, it is recommended to use a different name; for example, `cloudflare-ddns-go`.
4. Recreate the Docker container and then _you are done._

Here is a possible configuration after the migration:

```yaml
version: "3.7"
services:
  cloudflare-ddns-go:
    image: ghcr.io/favonia/cloudflare-ddns-go:latest
    container_name: cloudflare-ddns-go
    security_opt:
      - no-new-privileges:true
    network_mode: host
    environment:
      - PUID=1000
      - PGID=1000
      - COMPATIBLE=true
    volumes:
      - ${PWD}/cloudflare-ddns/config.json:/config.json
    restart: unless-stopped
```

### üòé New Mode

#### Step 1: Update `docker-compose.yml`

Incoporate the following fragment into your `docker-compose.yml` (or other equivalent ones).
```yaml
version: "3"
services:
  cloudflare-ddns-go:
    image: ghcr.io/favonia/cloudflare-ddns-go:latest
    container_name: cloudflare-ddns-go
    security_opt:
      - no-new-privileges:true
    network_mode: host
    environment:
      - CF_API_TOKEN
      - DOMAINS
      - PROXIED=true
    restart: unless-stopped
```

#### Step 2: Update `.env`

You should then add these lines in your `.env` file:
```sh
CF_API_TOKEN=YOUR-CLOUDFLARE-API-TOKEN
DOMAINS=www.example.org,www2.example.org
```

- The token can be obtained via the [API Tokens page](https://dash.cloudflare.com/profile/api-tokens). Create a token with the **Edit zone DNS** permission.

- The domain names should be fully qualified domain names (without the final dots) separated by commas. For example, `github.com, www.github.com`. (It is okay to have some spaces around the commas.)

Now the program should work.

#### Step 3: Customize

Here are all the environment variables the program checks. Note that, in the compatible mode (`COMPATIBLE=true`), only `PUID`, `PGID`, and `QUIET` (and `COMPATIBLE` itself) are functional; other variables are ignored.

| Name | Valid Values | Meaning | Required? | Default Value |
| ---- | ------------ | ------- | --------- | ------------- |
| `CF_API_TOKEN` | CloudFlare API tokens with the `DNS:Edit` permission | The token to access CloudFlare APIs | **Exactly one of `CF_API_TOKEN` and `CF_API_TOKEN_FILE` should be set** | N/A |
| `CF_API_TOKEN_FILE` | File paths | The file the path points to contains the token to access CloudFlare APIs | **Exactly one of `CF_API_TOKEN` and `CF_API_TOKEN_FILE` should be set** | N/A |
| `COMPATIBLE` | Boolean | Whether the program should mimic the original CloudFlare-DDNS | No | `false`
| `DOMAINS` | Comma-separated fully qualified domain names (but without the final periods) | All the domains this tool should update | **Yes** | N/A
| `IP4_POLICY` | `cloudflare`, `local`, and `unmanaged` | `cloudflare` means using the CloudFlare servers to obtain public IPv4 addresses. `local` means using the information associated with local network interfaces to obtain IPv4 addresses. `unmanaged` means the tool should simply leave the `A` records alone. | No | `cloudflare`
| `IP6_POLICY` | `cloudflare`, `local`, and `unmanaged` | (As above, but for IPv6 and `AAAA` records) | No | `cloudflare`
| `PGID` | POSIX Group ID | The effective group ID the program should assume (instead of being the `root`) | No | 1000
| `PROXIED` | Boolean | Whether new DNS records should be proxied by CloudFlare | No | `false`
| `PUID` | POSIX User ID | The effective user ID the program should assume (instead of being the `root`) | No | 1000
| `QUIET` | Boolean | Whether the program should reduce the reporting | No | `false`
| `REFRESH_INTERVAL` | Any positive time duration, with a unit, such as `1h` or `10m`. See [time.ParseDuration](https://golang.org/pkg/time/#ParseDuration) | The refresh interval for the program to re-check IPs and update DNS records (if necessary) | No | `5m`
| `TTL` | Time-to-live (TTL) values | The TTL values used to create new DNS records | No | `1` (meaning automatic)

In the above table, ‚ÄúBoolean‚Äù includes `1`, `t`, `T`, `TRUE`, `true`, `True`, `0`, `f`, `F`, `FALSE`, `false`, and `False`.

## üõ†Ô∏è Usage without Docker

```sh
go run cmd/ddns.go
```
The program does not take arguments directly. Instead, it checks the environment variables.

## üíñ Questions and Contributions

Questions and contributions are welcome! Consider opening a GitHub issue to initiate the discussion.
