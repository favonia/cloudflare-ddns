# üéâ CloudFlare DDNS in Go

This is a reimplementation of [timothymiller/cloudflare-ddns](https://github.com/timothymiller/cloudflare-ddns) **with many significant improvements.**

## üöß Status of the Project

The code is working well for me, but the repository is still young. The interface is subject to changes.

## üëè Notable Improvements

1. **It will _not_ delete any A or AAAA records** that are not specified by you. The way the original program handles stale records has surprised many people; see [timothymiller/cloudflare-ddns#52](https://github.com/timothymiller/cloudflare-ddns/pull/52) and [#57](https://github.com/timothymiller/cloudflare-ddns/pull/57), for example. This will never happen in the new implementation.
2. It is mainly **configured via environment variables,** which means all the settings can go into `.env` when using `docker-compose`. This immediately solves [timothymiller/cloudflare-ddns#35](https://github.com/timothymiller/cloudflare-ddns/pull/35) and [#41](https://github.com/timothymiller/cloudflare-ddns/pull/41).
3. It can also be a **drop-in replacement** with `COMPATIBLE=true`. See below.
4. It _will_ respect `PGID` and `PUID` and **drop the root privilege immediately.**
5. It can take fully qualified domain names and **find the correct zones IDs for you.**
6. It can be configured to obtain IP addresses **using local network interfaces**, solving [#36](https://github.com/timothymiller/cloudflare-ddns/issues/36).
7. It comes with **many technical improvements under the hood,** such as handling of pagination in the CloudFlare API (thanks to the official Go binding [cloudflare/cloudflare-go](https://github.com/cloudflare/cloudflare-go)), careful parsing of the JSON files, (still incomplete) timeout mechanism, caching (thanks to [patrickmn/go-cache](https://github.com/patrickmn/go-cache)), etc.

As a bonus, the implementation has a tiny footprint and **its Docker images are only of size about 5 MBs.** (The Docker image of the original CloudFlare-DDNS is also small, but this one is even smaller.)

## üõ†Ô∏è Setup with Docker Compose

### ü§ù Compatible Mode

Use this option if you already have a working JSON configuration for CloudFlare-DDNS and wish to keep it.

#### üö£ Migration Steps

1. Locate the container entry in your `docker-compose.yml` file (or equivalent files).
2. Change `timothyjmiller/cloudflare-ddns:latest` to `ghcr.io/favonia/cloudflare-ddns-go:latest`.
3. Add **`COMPATIBLE=true`** to `environment`.
4. Recreate the Docker container and then _you are done._

‚ö†Ô∏è If you have been specifying `container_name`, it is recommended to use a different name; for example, `cloudflare-ddns-go`.

‚ö†Ô∏è You should not need automatic restart (e.g., `restart: unless-stopped`) because the program should exit only when non-recoverable errors happen or when you manually stop it. Please consider reporting the bug if it exits for any other reasons.

‚ö†Ô∏è The item `network_mode: host` is for IPv6. If you wish to keep the network separated from the host network, check out the proper way to [Enable IPv6 support](https://docs.docker.com/config/daemon/ipv6/).

Here is a possible configuration after the migration:

```yaml
version: "3"
services:
  cloudflare-ddns-go:
    image: ghcr.io/favonia/cloudflare-ddns-go:latest
    container_name: cloudflare-ddns-go
    security_opt:
      - no-new-privileges:true
    network_mode: host
    environment:
      - PUID=1000
      - PGID=1000
      - COMPATIBLE=true
    volumes:
      - ${PWD}/cloudflare-ddns/config.json:/config.json
```

### üòé New Mode (Using Environment Variables)

Use this one if you wish to use any new features. The main limitation of the new configuration format is that it only accepts one API token while you can specify multiple API tokens in the JSON compatible mode.

#### Step 1: Updating `docker-compose.yml`

Incoporate the following fragment into your `docker-compose.yml` (or other equivalent files).

‚ö†Ô∏è The item `network_mode: host` is for IPv6. If you wish to keep the network separated from the host network, check out the proper way to [Enable IPv6 support](https://docs.docker.com/config/daemon/ipv6/).

```yaml
version: "3"
services:
  cloudflare-ddns-go:
    image: ghcr.io/favonia/cloudflare-ddns-go:latest
    container_name: cloudflare-ddns-go
    security_opt:
      - no-new-privileges:true
    network_mode: host
    environment:
      - CF_API_TOKEN
      - DOMAINS
      - PROXIED=true
```

#### Step 2: Updating `.env`

You should then add these lines in your `.env` file:
```sh
CF_API_TOKEN=YOUR-CLOUDFLARE-API-TOKEN
DOMAINS=www.example.org,www2.example.org
```

- The token can be obtained via the [API Tokens page](https://dash.cloudflare.com/profile/api-tokens). Create a token with the **Edit zone DNS** permission.

- The domain names should be fully qualified domain names (without the final dots) separated by commas. For example, `github.com, www.github.com`. (It is okay to have some spaces around the commas.)

The program should work now, but you might wish to customize it further:

#### Step 3: Customization

Here are all the environment variables the program checks. Note that, in the compatible mode (`COMPATIBLE=true`), only `PUID`, `PGID`, and `QUIET` (and `COMPATIBLE` itself) are functional; other variables are ignored.

| Name | Valid Values | Meaning | Required? | Default Value |
| ---- | ------------ | ------- | --------- | ------------- |
| `CF_API_TOKEN` | CloudFlare API tokens with the `DNS:Edit` permission | The token to access the CloudFlare API | **Exactly one of `CF_API_TOKEN` and `CF_API_TOKEN_FILE` should be set** | N/A |
| `CF_API_TOKEN_FILE` | File paths | The path to the file that contains the token to access the CloudFlare API | **Exactly one of `CF_API_TOKEN` and `CF_API_TOKEN_FILE` should be set** | N/A |
| `COMPATIBLE` | Boolean | Whether the program should mimic the original CloudFlare-DDNS | No | `false`
| `DOMAINS` | Comma-separated fully qualified domain names (but without the final periods) | All the domains this tool should update | **Yes** | N/A
| `IP4_POLICY` | `cloudflare`, `local`, and `unmanaged` | `cloudflare` means using the CloudFlare servers to obtain public IPv4 addresses. `local` means using the information associated with local network interfaces to obtain IPv4 addresses. `unmanaged` means the tool should simply leave the `A` records alone. | No | `cloudflare`
| `IP6_POLICY` | `cloudflare`, `local`, and `unmanaged` | (As above, but for IPv6 and `AAAA` records) | No | `cloudflare`
| `PGID` | POSIX Group ID | The effective group ID the program should assume (instead of being the `root`) | No | 1000
| `PROXIED` | Boolean | Whether new DNS records should be proxied by CloudFlare | No | `false`
| `PUID` | POSIX User ID | The effective user ID the program should assume (instead of being the `root`) | No | 1000
| `QUIET` | Boolean | Whether the program should reduce the reporting | No | `false`
| `REFRESH_INTERVAL` | Any positive time duration, with a unit, such as `1h` or `10m`. See [time.ParseDuration](https://golang.org/pkg/time/#ParseDuration) | The refresh interval for the program to re-check IPs and update DNS records (if necessary) | No | `5m`
| `TTL` | Time-to-live (TTL) values | The TTL values used to create new DNS records | No | `1` (meaning automatic)

‚ö†Ô∏è In the above table, ‚ÄúBoolean‚Äù means `1`, `t`, `T`, `TRUE`, `true`, `True`, `0`, `f`, `F`, `FALSE`, `false`, and `False`. See [strconv.ParseBool](https://golang.org/pkg/strconv/#ParseBool).

‚ö†Ô∏è You might need `network_mode: host` is for `IP4_POLICY=local` or `IP6_POLICY=local`, for otherwise the program will detect the address used by the container, not the host.

#### Alternative Setup with Docker Secret

The new mode can also work with [Docker secrets](https://docs.docker.com/engine/swarm/secrets/) if you wish to provide the API token via `docker secret`. (This advanced setup is not available to all Docker configurations.) Use `CF_API_TOKEN_FILE=/run/secrets/<secret_name>` instead of the `CF_API_TOKEN` variable to provide the token.

## üõ†Ô∏è Usage without Docker

```sh
go run cmd/ddns.go
```
The program does not take arguments directly. Instead, it checks the environment variables.

## üíñ Questions and Contributions

Questions and contributions are welcome! Consider opening a GitHub issue to initiate the discussion.
