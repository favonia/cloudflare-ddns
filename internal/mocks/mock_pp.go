// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/favonia/cloudflare-ddns/internal/pp (interfaces: PP)
//
// Generated by this command:
//
//	mockgen -typed -destination=../mocks/mock_pp.go -package=mocks . PP
//

// Package mocks is a generated GoMock package.
package mocks

import (
	reflect "reflect"

	pp "github.com/favonia/cloudflare-ddns/internal/pp"
	gomock "go.uber.org/mock/gomock"
)

// MockPP is a mock of PP interface.
type MockPP struct {
	ctrl     *gomock.Controller
	recorder *MockPPMockRecorder
	isgomock struct{}
}

// MockPPMockRecorder is the mock recorder for MockPP.
type MockPPMockRecorder struct {
	mock *MockPP
}

// NewMockPP creates a new mock instance.
func NewMockPP(ctrl *gomock.Controller) *MockPP {
	mock := &MockPP{ctrl: ctrl}
	mock.recorder = &MockPPMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPP) EXPECT() *MockPPMockRecorder {
	return m.recorder
}

// BlankLineIfVerbose mocks base method.
func (m *MockPP) BlankLineIfVerbose() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "BlankLineIfVerbose")
}

// BlankLineIfVerbose indicates an expected call of BlankLineIfVerbose.
func (mr *MockPPMockRecorder) BlankLineIfVerbose() *MockPPBlankLineIfVerboseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BlankLineIfVerbose", reflect.TypeOf((*MockPP)(nil).BlankLineIfVerbose))
	return &MockPPBlankLineIfVerboseCall{Call: call}
}

// MockPPBlankLineIfVerboseCall wrap *gomock.Call
type MockPPBlankLineIfVerboseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPPBlankLineIfVerboseCall) Return() *MockPPBlankLineIfVerboseCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPPBlankLineIfVerboseCall) Do(f func()) *MockPPBlankLineIfVerboseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPPBlankLineIfVerboseCall) DoAndReturn(f func()) *MockPPBlankLineIfVerboseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Indent mocks base method.
func (m *MockPP) Indent() pp.PP {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Indent")
	ret0, _ := ret[0].(pp.PP)
	return ret0
}

// Indent indicates an expected call of Indent.
func (mr *MockPPMockRecorder) Indent() *MockPPIndentCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Indent", reflect.TypeOf((*MockPP)(nil).Indent))
	return &MockPPIndentCall{Call: call}
}

// MockPPIndentCall wrap *gomock.Call
type MockPPIndentCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPPIndentCall) Return(arg0 pp.PP) *MockPPIndentCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPPIndentCall) Do(f func() pp.PP) *MockPPIndentCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPPIndentCall) DoAndReturn(f func() pp.PP) *MockPPIndentCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InfoOncef mocks base method.
func (m *MockPP) InfoOncef(id pp.ID, emoji pp.Emoji, format string, args ...any) {
	m.ctrl.T.Helper()
	varargs := []any{id, emoji, format}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "InfoOncef", varargs...)
}

// InfoOncef indicates an expected call of InfoOncef.
func (mr *MockPPMockRecorder) InfoOncef(id, emoji, format any, args ...any) *MockPPInfoOncefCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{id, emoji, format}, args...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InfoOncef", reflect.TypeOf((*MockPP)(nil).InfoOncef), varargs...)
	return &MockPPInfoOncefCall{Call: call}
}

// MockPPInfoOncefCall wrap *gomock.Call
type MockPPInfoOncefCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPPInfoOncefCall) Return() *MockPPInfoOncefCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPPInfoOncefCall) Do(f func(pp.ID, pp.Emoji, string, ...any)) *MockPPInfoOncefCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPPInfoOncefCall) DoAndReturn(f func(pp.ID, pp.Emoji, string, ...any)) *MockPPInfoOncefCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Infof mocks base method.
func (m *MockPP) Infof(emoji pp.Emoji, format string, args ...any) {
	m.ctrl.T.Helper()
	varargs := []any{emoji, format}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Infof", varargs...)
}

// Infof indicates an expected call of Infof.
func (mr *MockPPMockRecorder) Infof(emoji, format any, args ...any) *MockPPInfofCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{emoji, format}, args...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Infof", reflect.TypeOf((*MockPP)(nil).Infof), varargs...)
	return &MockPPInfofCall{Call: call}
}

// MockPPInfofCall wrap *gomock.Call
type MockPPInfofCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPPInfofCall) Return() *MockPPInfofCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPPInfofCall) Do(f func(pp.Emoji, string, ...any)) *MockPPInfofCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPPInfofCall) DoAndReturn(f func(pp.Emoji, string, ...any)) *MockPPInfofCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsShowing mocks base method.
func (m *MockPP) IsShowing(v pp.Verbosity) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsShowing", v)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsShowing indicates an expected call of IsShowing.
func (mr *MockPPMockRecorder) IsShowing(v any) *MockPPIsShowingCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsShowing", reflect.TypeOf((*MockPP)(nil).IsShowing), v)
	return &MockPPIsShowingCall{Call: call}
}

// MockPPIsShowingCall wrap *gomock.Call
type MockPPIsShowingCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPPIsShowingCall) Return(arg0 bool) *MockPPIsShowingCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPPIsShowingCall) Do(f func(pp.Verbosity) bool) *MockPPIsShowingCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPPIsShowingCall) DoAndReturn(f func(pp.Verbosity) bool) *MockPPIsShowingCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NoticeOncef mocks base method.
func (m *MockPP) NoticeOncef(id pp.ID, emoji pp.Emoji, format string, args ...any) {
	m.ctrl.T.Helper()
	varargs := []any{id, emoji, format}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "NoticeOncef", varargs...)
}

// NoticeOncef indicates an expected call of NoticeOncef.
func (mr *MockPPMockRecorder) NoticeOncef(id, emoji, format any, args ...any) *MockPPNoticeOncefCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{id, emoji, format}, args...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NoticeOncef", reflect.TypeOf((*MockPP)(nil).NoticeOncef), varargs...)
	return &MockPPNoticeOncefCall{Call: call}
}

// MockPPNoticeOncefCall wrap *gomock.Call
type MockPPNoticeOncefCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPPNoticeOncefCall) Return() *MockPPNoticeOncefCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPPNoticeOncefCall) Do(f func(pp.ID, pp.Emoji, string, ...any)) *MockPPNoticeOncefCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPPNoticeOncefCall) DoAndReturn(f func(pp.ID, pp.Emoji, string, ...any)) *MockPPNoticeOncefCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Noticef mocks base method.
func (m *MockPP) Noticef(emoji pp.Emoji, format string, args ...any) {
	m.ctrl.T.Helper()
	varargs := []any{emoji, format}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Noticef", varargs...)
}

// Noticef indicates an expected call of Noticef.
func (mr *MockPPMockRecorder) Noticef(emoji, format any, args ...any) *MockPPNoticefCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{emoji, format}, args...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Noticef", reflect.TypeOf((*MockPP)(nil).Noticef), varargs...)
	return &MockPPNoticefCall{Call: call}
}

// MockPPNoticefCall wrap *gomock.Call
type MockPPNoticefCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPPNoticefCall) Return() *MockPPNoticefCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPPNoticefCall) Do(f func(pp.Emoji, string, ...any)) *MockPPNoticefCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPPNoticefCall) DoAndReturn(f func(pp.Emoji, string, ...any)) *MockPPNoticefCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Suppress mocks base method.
func (m *MockPP) Suppress(id pp.ID) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Suppress", id)
}

// Suppress indicates an expected call of Suppress.
func (mr *MockPPMockRecorder) Suppress(id any) *MockPPSuppressCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Suppress", reflect.TypeOf((*MockPP)(nil).Suppress), id)
	return &MockPPSuppressCall{Call: call}
}

// MockPPSuppressCall wrap *gomock.Call
type MockPPSuppressCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPPSuppressCall) Return() *MockPPSuppressCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPPSuppressCall) Do(f func(pp.ID)) *MockPPSuppressCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPPSuppressCall) DoAndReturn(f func(pp.ID)) *MockPPSuppressCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
