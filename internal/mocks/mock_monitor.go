// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/favonia/cloudflare-ddns/internal/monitor (interfaces: BasicMonitor,Monitor)
//
// Generated by this command:
//
//	mockgen -typed -destination=../mocks/mock_monitor.go -package=mocks . BasicMonitor,Monitor
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	monitor "github.com/favonia/cloudflare-ddns/internal/monitor"
	pp "github.com/favonia/cloudflare-ddns/internal/pp"
	gomock "go.uber.org/mock/gomock"
)

// MockBasicMonitor is a mock of BasicMonitor interface.
type MockBasicMonitor struct {
	ctrl     *gomock.Controller
	recorder *MockBasicMonitorMockRecorder
	isgomock struct{}
}

// MockBasicMonitorMockRecorder is the mock recorder for MockBasicMonitor.
type MockBasicMonitorMockRecorder struct {
	mock *MockBasicMonitor
}

// NewMockBasicMonitor creates a new mock instance.
func NewMockBasicMonitor(ctrl *gomock.Controller) *MockBasicMonitor {
	mock := &MockBasicMonitor{ctrl: ctrl}
	mock.recorder = &MockBasicMonitorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBasicMonitor) EXPECT() *MockBasicMonitorMockRecorder {
	return m.recorder
}

// Describe mocks base method.
func (m *MockBasicMonitor) Describe(yield func(string, string) bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Describe", yield)
}

// Describe indicates an expected call of Describe.
func (mr *MockBasicMonitorMockRecorder) Describe(yield any) *MockBasicMonitorDescribeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Describe", reflect.TypeOf((*MockBasicMonitor)(nil).Describe), yield)
	return &MockBasicMonitorDescribeCall{Call: call}
}

// MockBasicMonitorDescribeCall wrap *gomock.Call
type MockBasicMonitorDescribeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBasicMonitorDescribeCall) Return() *MockBasicMonitorDescribeCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBasicMonitorDescribeCall) Do(f func(func(string, string) bool)) *MockBasicMonitorDescribeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBasicMonitorDescribeCall) DoAndReturn(f func(func(string, string) bool)) *MockBasicMonitorDescribeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Ping mocks base method.
func (m *MockBasicMonitor) Ping(ctx context.Context, ppfmt pp.PP, msg monitor.Message) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Ping", ctx, ppfmt, msg)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Ping indicates an expected call of Ping.
func (mr *MockBasicMonitorMockRecorder) Ping(ctx, ppfmt, msg any) *MockBasicMonitorPingCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockBasicMonitor)(nil).Ping), ctx, ppfmt, msg)
	return &MockBasicMonitorPingCall{Call: call}
}

// MockBasicMonitorPingCall wrap *gomock.Call
type MockBasicMonitorPingCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBasicMonitorPingCall) Return(arg0 bool) *MockBasicMonitorPingCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBasicMonitorPingCall) Do(f func(context.Context, pp.PP, monitor.Message) bool) *MockBasicMonitorPingCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBasicMonitorPingCall) DoAndReturn(f func(context.Context, pp.PP, monitor.Message) bool) *MockBasicMonitorPingCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockMonitor is a mock of Monitor interface.
type MockMonitor struct {
	ctrl     *gomock.Controller
	recorder *MockMonitorMockRecorder
	isgomock struct{}
}

// MockMonitorMockRecorder is the mock recorder for MockMonitor.
type MockMonitorMockRecorder struct {
	mock *MockMonitor
}

// NewMockMonitor creates a new mock instance.
func NewMockMonitor(ctrl *gomock.Controller) *MockMonitor {
	mock := &MockMonitor{ctrl: ctrl}
	mock.recorder = &MockMonitorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMonitor) EXPECT() *MockMonitorMockRecorder {
	return m.recorder
}

// Describe mocks base method.
func (m *MockMonitor) Describe(yield func(string, string) bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Describe", yield)
}

// Describe indicates an expected call of Describe.
func (mr *MockMonitorMockRecorder) Describe(yield any) *MockMonitorDescribeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Describe", reflect.TypeOf((*MockMonitor)(nil).Describe), yield)
	return &MockMonitorDescribeCall{Call: call}
}

// MockMonitorDescribeCall wrap *gomock.Call
type MockMonitorDescribeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMonitorDescribeCall) Return() *MockMonitorDescribeCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMonitorDescribeCall) Do(f func(func(string, string) bool)) *MockMonitorDescribeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMonitorDescribeCall) DoAndReturn(f func(func(string, string) bool)) *MockMonitorDescribeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Exit mocks base method.
func (m *MockMonitor) Exit(ctx context.Context, ppfmt pp.PP, message string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exit", ctx, ppfmt, message)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Exit indicates an expected call of Exit.
func (mr *MockMonitorMockRecorder) Exit(ctx, ppfmt, message any) *MockMonitorExitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exit", reflect.TypeOf((*MockMonitor)(nil).Exit), ctx, ppfmt, message)
	return &MockMonitorExitCall{Call: call}
}

// MockMonitorExitCall wrap *gomock.Call
type MockMonitorExitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMonitorExitCall) Return(arg0 bool) *MockMonitorExitCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMonitorExitCall) Do(f func(context.Context, pp.PP, string) bool) *MockMonitorExitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMonitorExitCall) DoAndReturn(f func(context.Context, pp.PP, string) bool) *MockMonitorExitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Log mocks base method.
func (m *MockMonitor) Log(ctx context.Context, ppfmt pp.PP, msg monitor.Message) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Log", ctx, ppfmt, msg)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Log indicates an expected call of Log.
func (mr *MockMonitorMockRecorder) Log(ctx, ppfmt, msg any) *MockMonitorLogCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Log", reflect.TypeOf((*MockMonitor)(nil).Log), ctx, ppfmt, msg)
	return &MockMonitorLogCall{Call: call}
}

// MockMonitorLogCall wrap *gomock.Call
type MockMonitorLogCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMonitorLogCall) Return(arg0 bool) *MockMonitorLogCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMonitorLogCall) Do(f func(context.Context, pp.PP, monitor.Message) bool) *MockMonitorLogCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMonitorLogCall) DoAndReturn(f func(context.Context, pp.PP, monitor.Message) bool) *MockMonitorLogCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Ping mocks base method.
func (m *MockMonitor) Ping(ctx context.Context, ppfmt pp.PP, msg monitor.Message) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Ping", ctx, ppfmt, msg)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Ping indicates an expected call of Ping.
func (mr *MockMonitorMockRecorder) Ping(ctx, ppfmt, msg any) *MockMonitorPingCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockMonitor)(nil).Ping), ctx, ppfmt, msg)
	return &MockMonitorPingCall{Call: call}
}

// MockMonitorPingCall wrap *gomock.Call
type MockMonitorPingCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMonitorPingCall) Return(arg0 bool) *MockMonitorPingCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMonitorPingCall) Do(f func(context.Context, pp.PP, monitor.Message) bool) *MockMonitorPingCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMonitorPingCall) DoAndReturn(f func(context.Context, pp.PP, monitor.Message) bool) *MockMonitorPingCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Start mocks base method.
func (m *MockMonitor) Start(ctx context.Context, ppfmt pp.PP, message string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start", ctx, ppfmt, message)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockMonitorMockRecorder) Start(ctx, ppfmt, message any) *MockMonitorStartCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockMonitor)(nil).Start), ctx, ppfmt, message)
	return &MockMonitorStartCall{Call: call}
}

// MockMonitorStartCall wrap *gomock.Call
type MockMonitorStartCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMonitorStartCall) Return(arg0 bool) *MockMonitorStartCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMonitorStartCall) Do(f func(context.Context, pp.PP, string) bool) *MockMonitorStartCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMonitorStartCall) DoAndReturn(f func(context.Context, pp.PP, string) bool) *MockMonitorStartCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
