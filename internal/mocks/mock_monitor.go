// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/favonia/cloudflare-ddns/internal/monitor (interfaces: Monitor)
//
// Generated by this command:
//
//	mockgen -typed -destination=../mocks/mock_monitor.go -package=mocks . Monitor
//
// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	pp "github.com/favonia/cloudflare-ddns/internal/pp"
	gomock "go.uber.org/mock/gomock"
)

// MockMonitor is a mock of Monitor interface.
type MockMonitor struct {
	ctrl     *gomock.Controller
	recorder *MockMonitorMockRecorder
}

// MockMonitorMockRecorder is the mock recorder for MockMonitor.
type MockMonitorMockRecorder struct {
	mock *MockMonitor
}

// NewMockMonitor creates a new mock instance.
func NewMockMonitor(ctrl *gomock.Controller) *MockMonitor {
	mock := &MockMonitor{ctrl: ctrl}
	mock.recorder = &MockMonitorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMonitor) EXPECT() *MockMonitorMockRecorder {
	return m.recorder
}

// Describe mocks base method.
func (m *MockMonitor) Describe(arg0 func(string, string)) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Describe", arg0)
}

// Describe indicates an expected call of Describe.
func (mr *MockMonitorMockRecorder) Describe(arg0 any) *MonitorDescribeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Describe", reflect.TypeOf((*MockMonitor)(nil).Describe), arg0)
	return &MonitorDescribeCall{Call: call}
}

// MonitorDescribeCall wrap *gomock.Call
type MonitorDescribeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MonitorDescribeCall) Return() *MonitorDescribeCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MonitorDescribeCall) Do(f func(func(string, string))) *MonitorDescribeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MonitorDescribeCall) DoAndReturn(f func(func(string, string))) *MonitorDescribeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ExitStatus mocks base method.
func (m *MockMonitor) ExitStatus(arg0 context.Context, arg1 pp.PP, arg2 int, arg3 string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExitStatus", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(bool)
	return ret0
}

// ExitStatus indicates an expected call of ExitStatus.
func (mr *MockMonitorMockRecorder) ExitStatus(arg0, arg1, arg2, arg3 any) *MonitorExitStatusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExitStatus", reflect.TypeOf((*MockMonitor)(nil).ExitStatus), arg0, arg1, arg2, arg3)
	return &MonitorExitStatusCall{Call: call}
}

// MonitorExitStatusCall wrap *gomock.Call
type MonitorExitStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MonitorExitStatusCall) Return(arg0 bool) *MonitorExitStatusCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MonitorExitStatusCall) Do(f func(context.Context, pp.PP, int, string) bool) *MonitorExitStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MonitorExitStatusCall) DoAndReturn(f func(context.Context, pp.PP, int, string) bool) *MonitorExitStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Failure mocks base method.
func (m *MockMonitor) Failure(arg0 context.Context, arg1 pp.PP, arg2 string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Failure", arg0, arg1, arg2)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Failure indicates an expected call of Failure.
func (mr *MockMonitorMockRecorder) Failure(arg0, arg1, arg2 any) *MonitorFailureCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Failure", reflect.TypeOf((*MockMonitor)(nil).Failure), arg0, arg1, arg2)
	return &MonitorFailureCall{Call: call}
}

// MonitorFailureCall wrap *gomock.Call
type MonitorFailureCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MonitorFailureCall) Return(arg0 bool) *MonitorFailureCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MonitorFailureCall) Do(f func(context.Context, pp.PP, string) bool) *MonitorFailureCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MonitorFailureCall) DoAndReturn(f func(context.Context, pp.PP, string) bool) *MonitorFailureCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Log mocks base method.
func (m *MockMonitor) Log(arg0 context.Context, arg1 pp.PP, arg2 string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Log", arg0, arg1, arg2)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Log indicates an expected call of Log.
func (mr *MockMonitorMockRecorder) Log(arg0, arg1, arg2 any) *MonitorLogCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Log", reflect.TypeOf((*MockMonitor)(nil).Log), arg0, arg1, arg2)
	return &MonitorLogCall{Call: call}
}

// MonitorLogCall wrap *gomock.Call
type MonitorLogCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MonitorLogCall) Return(arg0 bool) *MonitorLogCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MonitorLogCall) Do(f func(context.Context, pp.PP, string) bool) *MonitorLogCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MonitorLogCall) DoAndReturn(f func(context.Context, pp.PP, string) bool) *MonitorLogCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Start mocks base method.
func (m *MockMonitor) Start(arg0 context.Context, arg1 pp.PP, arg2 string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start", arg0, arg1, arg2)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockMonitorMockRecorder) Start(arg0, arg1, arg2 any) *MonitorStartCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockMonitor)(nil).Start), arg0, arg1, arg2)
	return &MonitorStartCall{Call: call}
}

// MonitorStartCall wrap *gomock.Call
type MonitorStartCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MonitorStartCall) Return(arg0 bool) *MonitorStartCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MonitorStartCall) Do(f func(context.Context, pp.PP, string) bool) *MonitorStartCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MonitorStartCall) DoAndReturn(f func(context.Context, pp.PP, string) bool) *MonitorStartCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Success mocks base method.
func (m *MockMonitor) Success(arg0 context.Context, arg1 pp.PP, arg2 string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Success", arg0, arg1, arg2)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Success indicates an expected call of Success.
func (mr *MockMonitorMockRecorder) Success(arg0, arg1, arg2 any) *MonitorSuccessCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Success", reflect.TypeOf((*MockMonitor)(nil).Success), arg0, arg1, arg2)
	return &MonitorSuccessCall{Call: call}
}

// MonitorSuccessCall wrap *gomock.Call
type MonitorSuccessCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MonitorSuccessCall) Return(arg0 bool) *MonitorSuccessCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MonitorSuccessCall) Do(f func(context.Context, pp.PP, string) bool) *MonitorSuccessCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MonitorSuccessCall) DoAndReturn(f func(context.Context, pp.PP, string) bool) *MonitorSuccessCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
